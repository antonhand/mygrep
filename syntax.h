#ifndef SYNTAX_H_INCLUDED
#define SYNTAX_H_INCLUDED
/*!
*\file
*\brief Заголовочный файл синтаксического анализатора
*
* Данный файл содержит в себе определения класса синтаксического анализатора
*/

#include "lexic.h"

#include <vector>
#include <string>

///Синтаксические лексемы
class Syn_lexem
{
    friend class Syntax;
    friend class Mygrep;

    Lexem::lexem_types type;        ///< Тип лексемы
    string terminal = "";           ///< Терминальная цепочка
    int param1 = 0;                 ///< Первый параметр лексемы
    int param2 = 0;                 ///< Второй параметр лексемы

    vector<Syn_lexem> operand1;     ///< Первый операнд
    vector<Syn_lexem> operand2;     ///< Второй операнд

    /*!
    * Конструктор построения синтаксической лексемы по обычной
    * \param[in] lexem Обычная лексема
    */
    Syn_lexem(Lexem &lexem);

    /*!
    * Конструктор лексемы итерация от 0 до param2 раз
    * \param[in] param2 Максимальное количество итераций
    * \param[in] operand Операнд итерации
    */
    Syn_lexem(int param2, vector<Syn_lexem> operand);

    /*!
    * Печать лексемы
    */
    void print();
};

/*! \brief Синтаксический анализатор
 *
 * Синтаксический анализатор проверяет последовательность типизированных лексем на соответствии грамматике языка регулярных выражений
 * и переводит последотельность во внутреннее представление (последовательность синтаксических лексем)
 */
class Syntax
{
    friend class Mygrep;
    Lex scan;                   ///< Лексический анализатор
    Lexem cur;                  ///< Текущая лексема
    int countbrace = 0;         ///< Счётчик скобок
    vector<Syn_lexem> internal; ///< Внутреннее представление выражения

    ///Функция, получающая из лексического анализатора очередную лексему и записывающая её в переменную cur
    void gl();

    /// @name Функции РС-метода
    /// @{
    /*! \brief Начальное состояние
     *
     *  Либо обнаруживает пустую последовательность, либо переходит в состояние S1
     */
    void S();
    /*! \brief Основное состояние
     *
     * \return Возвращают сгенерированную подпоследовательность внутреннего представления
     */
    vector<Syn_lexem> S1(bool concat = false);
    /*! \brief Состояние поиска унарного оператора
     *
     * \return Возвращают сгенерированную подпоследовательность внутреннего представления
     */
    vector<Syn_lexem> O(vector<Syn_lexem> &operand);
    /// @}

    /*! \brief Конструктор от строки с регулярным выражением.
     *
     * Сделан явным, поскольку неясен смысл выражения вида Syntax c = "a*";
     */
    explicit Syntax(const string &reg);

    /*! \brief Функция, возвращающая внутреннее представление
     *
     * \return Возвращают сгенерированное внутреннего представления выражения
     */
    vector<Syn_lexem> get_internal();
};

#endif // SYNTAX_H_INCLUDED
